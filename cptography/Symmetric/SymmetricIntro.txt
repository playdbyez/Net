
[] Symmetric Ciphering []


.Encryption  
m = plainText.priv  
e = function.pub  
k = key.priv  
c = cipherText.pub  
 
c = e^k(m)  


.Decryption  
c = cipherText   
e = function  
k = key  
m = plainText   
 
m = d^k(c)  



> Ciphering is a means of turning plaintext into ciphertext under the 
  control of a key.  

> Within a symmetric scheme we considering the cipher's size in bits and 
  the key must be known by both communicating parties only.
  Sometimes two keys are employed, one for encryption and another for decryption.

> Secrecy of the mesage depends on the secrecy of the key, thus they must change
  on a per message or per session basis.

> The simplest and hence fastest computational operation is ⊕.

> Security of the cipher depends on 
  1. how hard it is to perfrom an exhaustive key search against it.  
  2. how well hidden is the underlying statistics of the language used.  

> Since it is possible to turn one plaintext into two ciphers or more, the ammount of ciphers present must be bigger or  equal to the mount of plaintext characters,and because it is possible to have used a different key per character, the key length must be bigger or equal to the ammount of cipher characters. 

> A typical approach is to first us a public key scheme to determine session keys/ message keys
  then encrypt communication via either a stream or block cipher.

> When implementing any sort of encryption along a channel, its necessary to 
  first determine randomness of the cypher key between both end-points.

> A bulk cipher is a speed oriented cipher of the symmetric variety, namely stream ciphers and block ciphers.
  Bulk ciphers are broken either through:
   - Passive Attack
           >> Aimed at either recoverin the key or decrypting parts of the message
           >> Only allowed to listen to encrypted transmissions (traffic analysis)
           >> Easier to mount

   - Active Attack
           >> Allowed to insert and deleteme messages or replay them (insertion attack)
           >> Easily detectable



[] Design Goals [] 
> Encryption and decryption functions should be public in order to ascertain that they are provably secure.
> Computationally secure against ehxaustive key search.
> Compromising some secrecy for efficiency since these are used for bulk encryption.
> Reusable keys and short keys for long messages.
> Ciphers should implement detection and recovery mechanisms against replay attacks.
> Attackers should know some plain/cipher pairs associated with the key.


TYPES OF ATTACKS

Brute Force
Extensive Key Search
Cipher Only Attack
Known Plaintext Attack
Chosen Plaintext Attack
Chosen Ciphertext Attack
Key and Algorithm Attack
Side Channel Attacks
Replay Attacks



 ############::Chosen Plaintext Attack::##############  
Consists of the attacker obtaining a cipher equivalent
of his own message directly from the admin.


############::Known-Plaintext Attack::##############  
- cribb dragging



############::Insertion Attack::##############  




############::Implementation Attacks ::##############  
A Side channel attack would consist of employing an osciloscope against a microprocessor's pins
and recording the ondulation  or observe  the timing behaviour in hope to decode the key being used within the chip.  

  

############  Ciphertext Only Attacks ######

- Sinkov
When facing substitution ciphers, it is important to be able to distinguish natural language from noise. 
For said purpose we can compute the Sinkov Statistic through the following:
 
for i = A ... Z
Set F[i] = underlying language frequency
Set n[i] = ciphertext frequency
S = likelyhood that said text is an extract from a natural language
 
S = ᵢ₌ₐΣᶻ n[i] x F[i]


########### Repeat stream cipher messages ###
If the same key is used repeatedly, it can reveal a relationship between messages.
  Suppose Eve intercepts two messages:
    c1 = m1 ⊕ k 
    c2 = m2 ⊕ k 
  A relationship between m1 and m2 can be determined via:
    c1 ⊕ c2 = (m1 ⊕ k ) ⊕ (m2 ⊕ k) = m1 ⊕ m2



############::KeySearch::##############   
cipher key size = 64bits  
solution = 2^64 bits  
roughly = 2^88  
  
If the key manages a lookup table, we compare its character to  
its possibility of being said character from the alphabet (26 letters) granting us a 26! factorial.  
cipher[0] = 1 out of 26 letters of the alphabet  
cipher[1] = 1 out of 25 letters of the alphabet  
cipher[2] = 1 out of 24 letters of the alphabet ...  


  
https://www.youtube.com/watch?v=wlSG3pEiQdc
